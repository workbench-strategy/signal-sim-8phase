# 21 - Notebook Usage & Analysis Patterns

## ğŸ““ Purpose

Enable exploratory development and analysis in a structured, reproducible format using Jupyter Notebooks and best-practice patterns.

## ğŸ“ Directory

```
notebooks/
â”œâ”€â”€ 01-eda.ipynb        # Exploratory data analysis
â”œâ”€â”€ 02-llm-tests.ipynb  # LLM response trials
â””â”€â”€ utils.ipynb         # Shared helper functions
```

## ğŸ§° Tools

* JupyterLab or VSCode Notebooks
* IPython magic (`%time`, `%load_ext autoreload`)
* `nbstripout` or `jupyter nbconvert` for clean diffs

## ğŸ’¡ Patterns

* Keep notebooks focused and named numerically
* Move tested code into `src/` as reusable modules
* Use `.py` scripts for logic and import them in notebooks

---

# 22 - Deployment Recipes (GCP, Pi, Docker, Local)

## ğŸš€ Deploy Modes

### ğŸ§ª Local Dev

```bash
poetry install
python src/cli/main.py
```

### ğŸ³ Docker

```bash
docker compose up --build
```

### â˜ï¸ GCP Cloud Run

```bash
gcloud run deploy ...
```

### ğŸ“ Raspberry Pi

```bash
rsync -avz ./ pi@raspberrypi.local:/home/pi/project
ssh pi@raspberrypi.local
python src/cli/main.py
```

---

# 23 - Middleware & Core Architecture Layer

## ğŸ¯ Purpose

Abstract shared logic into a reusable layer that decouples domain-specific components from core utilities.

## Structure

```
src/core/
â”œâ”€â”€ middleware.py
â”œâ”€â”€ logger.py
â”œâ”€â”€ config.py
```

## Best Practices

* Dependency-free core when possible
* Use factories or adapters to integrate with external services
* Middleware for logging, error capture, retries

---

# 24 - API Integrations & Secrets Management

## ğŸ¤ Strategy

Design for modular, secure, and swappable API client modules.

## Structure

```
src/llm/
â”œâ”€â”€ openai.py
â”œâ”€â”€ anthropic.py
â”œâ”€â”€ huggingface.py
```

## Patterns

* Use `.env` or Secret Manager
* Wrap each API call in a retry-safe function
* Create interface-like base classes or helper mixins

---

# 25 - Real-Time Tools & Audio/MIDI Hooks

## ğŸ¶ Purpose

Facilitate event-driven, time-aware interactions in music pipelines or sensor-based projects.

## Tools

* `mido`, `python-rtmidi`
* `asyncio`, `websockets`
* `RPi.GPIO` for hardware IO

## Structure

```
src/realtime/
â”œâ”€â”€ midi_handler.py
â”œâ”€â”€ sensor_loop.py
â”œâ”€â”€ dispatcher.py
```

## Patterns

* Use `async def` event loops
* Maintain a `Clock` or scheduler abstraction
* Integrate with CLI or systemd to daemonize

---

ğŸ‰ These five advanced docs provide dynamic interactivity, API extensibility, and deployment flexibility across platforms.
